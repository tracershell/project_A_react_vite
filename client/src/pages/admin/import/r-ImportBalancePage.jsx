// client/src/pages/admin/import/ImportBalancePage.jsx

import React, { useEffect, useState, useRef } from 'react';
import axios from 'axios';
import styles from './ImportBalancePage.module.css';
import { useLocation, useNavigate } from 'react-router-dom';

const ImportBalancePage = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { rows = [], vendor_id, vendor_name, deposit_rate } = location.state || {};

  const [dataSource, setDataSource] = useState('temp');
  const [records, setRecords] = useState([]);
  const [filtered, setFiltered] = useState([]);
  const [bpDate, setBpDate] = useState('');
  const [exRate, setExRate] = useState('');
  const [search, setSearch] = useState({ bp_date: '', style: '', po_no: '' });
  const [availableDates, setAvailableDates] = useState([]);
  const [totalRmb, setTotalRmb] = useState(0);
  const [totalUsd, setTotalUsd] = useState(0);

  const [extraList, setExtraList] = useState([]);
  const [extraForm, setExtraForm] = useState({
    extra_no: '', po_no: '', rate_apply: '', comment: '', amount: ''
  });
  const [autoGeneratedPoNo, setAutoGeneratedPoNo] = useState('');
  const [autoRateApply, setAutoRateApply] = useState('');

  const cleanDate = (d) => {
    if (!d) return '';
    if (typeof d === 'string' && d.includes('-')) return d;
    const dt = new Date(d);
    return dt.toISOString().split('T')[0];
  };

  useEffect(() => {
    if (rows.length > 0) {
      setRecords(rows);
    } else {
      fetchBalanceTemp();
    }
    fetchExtraList();
  }, []);

  useEffect(() => {
    fetchRecords();
    setSearch({ bp_date: '', style: '', po_no: '' });
  }, [dataSource]);

  useEffect(() => {
    if (dataSource === 'final') {
      axios.get('/api/admin/import/balance/dates')
        .then(res => setAvailableDates(res.data))
        .catch(err => console.error('❌ bp_date 목록 실패', err));
    }
  }, [dataSource]);

  const fetchBalanceTemp = () => {
    axios.get('/api/admin/import/balance/temp', { withCredentials: true })
      .then(({ data }) => setRecords(data))
      .catch(() => { });
  };

  const fetchRecords = () => {
    const url = dataSource === 'temp'
      ? '/api/admin/import/balance/temp'
      : '/api/admin/import/balance/final';
    axios.get(url, { withCredentials: true })
      .then(({ data }) => setRecords(data))
      .catch(() => alert('데이터 불러오기 실패'));
  };

  const fetchExtraList = () => {
    axios.get('/api/admin/import/extra', { withCredentials: true })
      .then(({ data }) => setExtraList(data))
      .catch(() => {});
  };

  useEffect(() => {
    if (!extraForm.extra_no) {
      setAutoRateApply('');
      setAutoGeneratedPoNo('');
      return;
    }
    const item = extraList.find(x => x.extra_no === extraForm.extra_no);
    if (item) {
      setAutoRateApply(item.rate_apply);
      const now = new Date();
      const po_no = `${item.po_no || 'EXTRA'}-${now.getTime()}`;
      setAutoGeneratedPoNo(po_no);
      setExtraForm(f => ({ ...f, po_no, rate_apply: item.rate_apply }));
    }
  }, [extraForm.extra_no, extraList]);

  const handleExtraChange = e => {
    const { name, value } = e.target;
    setExtraForm(f => ({ ...f, [name]: value }));
  };

  const handleAddExtra = async () => {
    const { extra_no, po_no, rate_apply, comment, amount } = extraForm;
    if (!extra_no || !po_no || !rate_apply || !amount) return alert('모든 항목을 입력하세요');
    const today = cleanDate(new Date());
    const vid = vendor_id || records[0]?.vendor_id;
    const vname = vendor_name || records[0]?.vendor_name;
    const vrate = deposit_rate || records[0]?.deposit_rate;

    let bp_amount_rmb = 0, bp_amount_usd = 0, bp_exrate = null;
    if (rate_apply === '환율적용') {
      bp_amount_rmb = Number(amount);
    } else {
      bp_amount_usd = Number(amount);
      bp_exrate = 1;
    }

    try {
      await axios.post('/api/admin/import/balance/po/add', {
        vendor_id: vid, po_date: today, style_no: extra_no, po_no, pcs: 0,
        cost_rmb: 0, note: `[EXTRA] ${comment}`
      }, { withCredentials: true });

      setRecords(rs => [
        ...rs,
        { id: po_no, vendor_id: vid, vendor_name: vname, deposit_rate: vrate,
          po_date: today, style_no: extra_no, po_no, pcs: 0, cost_rmb: 0,
          t_amount_rmb: 0, dp_amount_rmb: 0, bp_amount_rmb, bp_amount_usd, bp_exrate,
          comment, isExtra: true }
      ]);

      setExtraForm({ extra_no: '', po_no: '', rate_apply: '', comment: '', amount: '' });
      setAutoGeneratedPoNo('');
      alert('Extra Pay 추가 완료');
    } catch {
      alert('Extra 추가 실패');
    }
  };

  const applyExRate = async () => {
    if (!bpDate || !exRate) return alert('필수 입력');
    const updated = records.map(r => {
      if ((r.bp_exrate === 1) && r.bp_amount_rmb === 0) {
        return { ...r, bp_date: bpDate, bp_exrate: 1 };
      }
      const t = r.t_amount_rmb || (r.pcs * r.cost_rmb);
      const bpR = Number(((t * (100 - (r.deposit_rate || deposit_rate))) / 100).toFixed(2));
      return {
        ...r,
        bp_date: cleanDate(bpDate),
        bp_exrate: exRate,
        bp_amount_rmb: bpR,
        bp_amount_usd: exRate ? (bpR / parseFloat(exRate)).toFixed(2) : ''
      };
    });
    setRecords(updated);
    try {
      await axios.post('/api/admin/import/balance/temp/update', { rows: updated }, { withCredentials: true });
    } catch {
      alert('서버 저장 실패');
    }
  };

  const handlePay = async () => {
    if (!bpDate || !exRate) return alert('필수 입력');
    const cleaned = records.map(r => ({
      ...r,
      po_date: cleanDate(r.po_date),
      bp_date: cleanDate(bpDate),
      bp_exrate: r.bp_exrate || exRate,
      bp_amount_rmb: r.bp_amount_rmb || 0,
      bp_amount_usd: r.bp_amount_usd || 0,
      vendor_id: r.vendor_id || vendor_id,
      vendor_name: r.vendor_name || vendor_name,
      deposit_rate: r.deposit_rate || deposit_rate,
      bp_status: 'paid'
    }));
    try {
      await axios.post('/api/admin/import/balance/batchAdd', { rows: cleaned, vendor_id, vendor_name, deposit_rate }, { withCredentials: true });
      await axios.post('/api/admin/import/balance/temp/commit', { bp_date: cleanDate(bpDate), bp_exrate: exRate }, { withCredentials: true });
      alert('정상 저장 완료');
      navigate('/admin/import/po');
    } catch {
      alert('저장 오류 발생');
    }
  };

  useEffect(() => {
    let sumR = 0, sumU = 0;
    records.forEach(r => {
      const bp = Number(r.bp_amount_rmb || 0);
      const u = parseFloat(r.bp_amount_usd);
      if (!isNaN(bp)) sumR += bp;
      if (!isNaN(u)) sumU += u;
    });
    setTotalRmb(sumR);
    setTotalUsd(sumU);
    setFiltered(records);
  }, [records]);

  return (
    <div className={styles.page}>
      <h2>Extra Pay Input</h2>
      <div className={styles.formRow}>
        <select name="extra_no" value={extraForm.extra_no} onChange={handleExtraChange}>
          <option value="">선택</option>
          {extraList.map(x => <option key={x.id} value={x.extra_no}>{x.extra_no}</option>)}
        </select>
        <input name="po_no" value={autoGeneratedPoNo} readOnly />
        <select name="rate_apply" value={autoRateApply} readOnly>
          <option value="">선택</option>
          <option value="환율적용">환율적용</option>
          <option value="환율비적용">환율비적용</option>
        </select>
        <input name="comment" value={extraForm.comment} onChange={handleExtraChange} placeholder="Comment" />
        <input name="amount" type="number" value={extraForm.amount} onChange={handleExtraChange} placeholder="Amount" />
        <button onClick={handleAddExtra}>Add</button>
      </div>

      <h2>Balance Pay List</h2>
      <div className={styles.formRow}>
        <label>Data Source:</label>
        <select value={dataSource} onChange={e => setDataSource(e.target.value)}>
          <option value="temp">임시</option>
          <option value="final">확정</option>
        </select>
        {dataSource === 'final' && (
          <select value={search.bp_date} onChange={e => setSearch(s => ({ ...s, bp_date: e.target.value }))}>
            <option value="">:: 전체 날짜 보기 ::</option>
            {availableDates.map(d => <option key={d} value={d}>{d}</option>)}
          </select>
        )}
        <input placeholder="Style" value={search.style} onChange={e => setSearch(s => ({ ...s, style: e.target.value }))} />
        <input placeholder="PO no." value={search.po_no} onChange={e => setSearch(s => ({ ...s, po_no: e.target.value }))} />
        <button onClick={() => handleSearch()}>검색</button>
        <button onClick={() => handleFilteredPdf()}>PDF 보기</button>
      </div>

      <div className={styles.formRow}>
        <span>Pay Date:</span>
        <input type="date" value={bpDate} onChange={e => setBpDate(e.target.value)} />
        <span>Exchange Rate:</span>
        <input type="number" step="0.0001" value={exRate} onChange={e => setExRate(e.target.value)} />
        <button onClick={applyExRate} disabled={dataSource === 'final'}>환율적용</button>
        <button onClick={handlePay} disabled={dataSource === 'final'}>Pay</button>
      </div>

      <table className={styles.compactTable}>
        <thead>
          <tr>
            <th>Vendor</th><th>PO Date</th><th>Style</th><th>PO No</th>
            <th>pcs</th><th>Cost</th><th>Total</th><th>DP</th><th>BP</th>
            <th>BP Date</th><th>BP Rate</th><th>USD</th>
          </tr>
        </thead>
        <tbody>
          {filtered.map(r => (
            <tr key={r.id}>
              <td>{r.vendor_name}</td>
              <td>{cleanDate(r.po_date)}</td>
              <td>{r.style_no}</td>
              <td>{r.po_no}</td>
              <td>{r.pcs}</td>
              <td>{r.cost_rmb}</td>
              <td>{r.t_amount_rmb}</td>
              <td>{r.dp_amount_rmb}</td>
              <td>{r.bp_amount_rmb}</td>
              <td>{cleanDate(r.bp_date)}</td>
              <td>{r.bp_exrate}</td>
              <td>{r.bp_amount_usd}</td>
            </tr>
          ))}
        </tbody>
        <tfoot>
          <tr>
            <td colSpan="8">합계</td>
            <td>{totalRmb.toFixed(2)}</td>
            <td></td><td></td><td>{totalUsd.toFixed(2)}</td>
          </tr>
        </tfoot>
      </table>
    </div>
  );
};

export default ImportBalancePage;
